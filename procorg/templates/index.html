<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProcOrg - Process Manager</title>
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/bootstrap-icons.css">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        /* Minimal custom styles only for specific functionality */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .group-instances {
            display: none;
        }
        .group-instances.expanded {
            display: block;
        }
        .logs-accordion {
            display: none;
        }
        .logs-accordion.active {
            display: block;
        }
        .log-content {
            background: #1e1e1e;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            border-radius: 0.375rem;
        }
        .log-content:empty::before {
            content: 'No logs available';
            color: #6c757d;
            font-style: italic;
        }
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #198754;
            display: inline-block;
        }
        .status-indicator.stopped {
            background: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container-fluid px-4 py-3">
        <!-- Header Card -->
        <div class="card mb-4 border-start border-primary border-4">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <div>
                        <h1 class="h3 text-primary mb-1">ProcOrg</h1>
                        <p class="text-muted small mb-0">Process Orchestration and Management</p>
                    </div>
                    <div class="d-flex align-items-center gap-3">
                        <span class="text-success fw-semibold" id="user-name">Loading...</span>
                        <button class="btn btn-secondary btn-sm" onclick="logout()">Logout</button>
                    </div>
                </div>
                <div class="d-flex justify-content-between align-items-center pt-3 border-top">
                    <div class="d-flex align-items-center gap-2">
                        <div class="status-indicator" id="scheduler-indicator"></div>
                        <span class="small" id="scheduler-status">Scheduler: Loading...</span>
                    </div>
                    <button id="scheduler-toggle" class="btn btn-secondary btn-sm" onclick="toggleScheduler()">Start Scheduler</button>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <ul class="nav nav-tabs mb-4" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" onclick="switchTab('launchable')">Launchable Processes</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" onclick="switchTab('running')">Running Processes</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" onclick="switchTab('stopped')">Stopped Processes</button>
            </li>
        </ul>

        <!-- Tab 1: Launchable Processes -->
        <div id="launchable-tab" class="tab-content active">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h2 class="h5 mb-0">Launchable Processes</h2>
                <button class="btn btn-success" onclick="openRegisterModal()">
                    <i class="bi bi-plus-lg"></i> Add Process
                </button>
            </div>
            <div class="list-group" id="launchable-list">
                <!-- Launchable processes will be inserted here -->
            </div>
        </div>

        <!-- Tab 2: Running Processes -->
        <div id="running-tab" class="tab-content">
            <div class="mb-3">
                <h2 class="h5 mb-0">Running Processes</h2>
            </div>
            <div id="running-list">
                <!-- Running processes will be inserted here -->
            </div>
        </div>

        <!-- Tab 3: Stopped Processes -->
        <div id="stopped-tab" class="tab-content">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h2 class="h5 mb-0">Stopped Processes</h2>
                <button class="btn btn-danger" onclick="clearStoppedProcesses()">Clear List</button>
            </div>
            <div id="stopped-list">
                <!-- Stopped processes will be inserted here -->
            </div>
        </div>

        <!-- Launch Arguments Modal -->
        <div class="modal" id="launch-modal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Launch Process</h5>
                        <button type="button" class="btn-close" onclick="closeLaunchModal()"></button>
                    </div>
                    <div class="modal-body">
                        <div id="launch-message"></div>
                        <form id="launch-form" onsubmit="launchProcess(event)">
                            <input type="hidden" id="launch-process-name">
                            <div class="mb-3">
                                <label for="launch-args" class="form-label">Arguments (optional)</label>
                                <input type="text" class="form-control" id="launch-args" name="args"
                                       placeholder="arg1 arg2 arg3">
                                <div class="form-text">Space-separated arguments to pass to the script</div>
                            </div>
                            <div class="d-flex gap-2">
                                <button type="submit" class="btn btn-success">Launch</button>
                                <button type="button" class="btn btn-secondary" onclick="closeLaunchModal()">Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>

        <!-- Registration Modal -->
        <div class="modal" id="register-modal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Register New Process</h5>
                        <button type="button" class="btn-close" onclick="closeRegisterModal()"></button>
                    </div>
                    <div class="modal-body">
                        <div id="register-message"></div>
                        <form id="register-form" onsubmit="registerProcess(event)">
                            <div class="mb-3">
                                <label for="process-name" class="form-label">Process Name *</label>
                                <input type="text" class="form-control" id="process-name" name="name" required
                                       placeholder="e.g., my-backup-script">
                                <div class="form-text">Unique identifier for the process (no spaces)</div>
                            </div>

                            <div class="mb-3">
                                <label for="script-path" class="form-label">Script Path *</label>
                                <input type="text" class="form-control" id="script-path" name="script_path" required
                                       placeholder="e.g., /path/to/script.sh">
                                <div class="form-text">Absolute path to the shell script</div>
                            </div>

                            <div class="mb-3">
                                <label for="cron-expr" class="form-label">Cron Expression (optional)</label>
                                <input type="text" class="form-control" id="cron-expr" name="cron_expr"
                                       placeholder="e.g., 0 2 * * * (daily at 2 AM)">
                                <div class="form-text">Leave empty for manual execution only</div>
                            </div>

                            <div class="mb-3">
                                <label for="description" class="form-label">Description</label>
                                <textarea class="form-control" id="description" name="description" rows="3"
                                          placeholder="Brief description of what this process does"></textarea>
                            </div>

                            <div class="d-flex gap-2">
                                <button type="submit" class="btn btn-primary">Register Process</button>
                                <button type="button" class="btn btn-secondary" onclick="closeRegisterModal()">Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let currentTab = 'launchable';
        // Track active log accordions: {execution_id: {name, stream}}
        const activeLogs = {};

        // Check authentication
        async function checkAuth() {
            try {
                const response = await fetch('/api/whoami');
                if (response.ok) {
                    const result = await response.json();
                    if (result.authenticated) {
                        const userInfo = result.user;
                        document.getElementById('user-name').textContent = userInfo.username + (userInfo.is_root ? ' (root)' : '');
                        return true;
                    }
                }
                window.location.href = '/login';
                return false;
            } catch (error) {
                console.error('Auth check failed:', error);
                window.location.href = '/login';
                return false;
            }
        }

        async function logout() {
            try {
                await fetch('/api/logout', { method: 'POST' });
                window.location.href = '/login';
            } catch (error) {
                console.error('Logout failed:', error);
                window.location.href = '/login';
            }
        }

        // Tab switching
        function switchTab(tabName) {
            currentTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.nav-link').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');

            // Refresh data
            if (tabName === 'launchable') {
                updateLaunchableProcesses();
            } else if (tabName === 'running') {
                updateRunningProcesses();
            } else if (tabName === 'stopped') {
                updateStoppedProcesses();
            }
        }

        // Update launchable processes
        async function updateLaunchableProcesses() {
            try {
                const response = await fetch('/api/processes');
                if (!response.ok) return;

                const processes = await response.json();
                const list = document.getElementById('launchable-list');

                if (processes.length === 0) {
                    list.innerHTML = '<div class="alert alert-info text-center"><i class="bi bi-inbox fs-1 d-block mb-3"></i>No processes registered yet. Click "Add Process" to get started.</div>';
                    return;
                }

                list.innerHTML = processes.map(proc => `
                    <div class="list-group-item d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <h6 class="mb-1 text-success">${proc.name}</h6>
                            <p class="mb-0 text-muted small">${proc.description || proc.script_path}</p>
                        </div>
                        <button class="btn btn-success btn-sm" onclick="openLaunchModal('${proc.name}')">Launch</button>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error fetching processes:', error);
            }
        }

        // Track expanded groups by process name
        const expandedGroups = new Set();

        // Update running processes
        async function updateRunningProcesses() {
            try {
                const response = await fetch('/api/processes/running');
                if (!response.ok) return;

                const groups = await response.json();
                const list = document.getElementById('running-list');

                if (groups.length === 0) {
                    list.innerHTML = '<div class="alert alert-info text-center"><i class="bi bi-hourglass-split fs-1 d-block mb-3"></i>No processes currently running</div>';
                    return;
                }

                // Save current expansion state before updating
                const currentExpandedGroups = new Set();
                groups.forEach((group, idx) => {
                    const elem = document.getElementById(`group-${group.name}`);
                    if (elem && elem.classList.contains('expanded')) {
                        currentExpandedGroups.add(group.name);
                    }
                });
                // Merge with persistent state
                currentExpandedGroups.forEach(name => expandedGroups.add(name));

                // Save log content before regenerating HTML
                const savedLogContent = {};
                groups.forEach(group => {
                    group.instances.forEach(inst => {
                        const logDiv = document.getElementById(`log-content-${inst.execution_id}`);
                        if (logDiv) {
                            savedLogContent[inst.execution_id] = logDiv.textContent;
                        }
                    });
                });

                list.innerHTML = groups.map((group, idx) => `
                    <div class="card mb-3 border-start border-success border-3">
                        <div class="card-header bg-dark cursor-pointer" onclick="toggleGroup('${group.name}')" style="cursor: pointer;">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h6 class="mb-1 text-success">${group.name}</h6>
                                    <p class="mb-0 text-muted small">${group.description || group.script_path}</p>
                                </div>
                                <span class="badge bg-success">${group.instances.length} running</span>
                            </div>
                        </div>
                        <div class="group-instances ${expandedGroups.has(group.name) ? 'expanded' : ''}" id="group-${group.name}">
                            <ul class="list-group list-group-flush">
                                ${group.instances.map(inst => `
                                    <li class="list-group-item">
                                        <div class="d-flex justify-content-between align-items-start mb-2">
                                            <div class="flex-grow-1">
                                                <div class="font-monospace small text-primary">ID: ${inst.execution_id}</div>
                                                <div class="text-muted small">
                                                    PID: ${inst.pid} | Started: ${new Date(inst.start_time).toLocaleString()}
                                                    ${inst.args && inst.args.length > 0 ? ` | Args: ${inst.args.join(' ')}` : ''}
                                                </div>
                                            </div>
                                            <div class="d-flex gap-2">
                                                <button class="btn btn-secondary btn-sm" onclick="toggleLogs('${group.name}', '${inst.execution_id}')">Logs</button>
                                                <button class="btn btn-danger btn-sm" onclick="stopProcess('${group.name}')">Stop</button>
                                            </div>
                                        </div>
                                        <div class="logs-accordion ${activeLogs[inst.execution_id] ? 'active' : ''}" id="logs-${inst.execution_id}">
                                            <div class="btn-group mb-3" role="group">
                                                <button type="button" class="btn btn-sm ${!activeLogs[inst.execution_id] || activeLogs[inst.execution_id].stream === 'stdout' ? 'btn-primary' : 'btn-secondary'}" onclick="switchStream('${group.name}', '${inst.execution_id}', 'stdout')">stdout</button>
                                                <button type="button" class="btn btn-sm ${activeLogs[inst.execution_id]?.stream === 'stderr' ? 'btn-primary' : 'btn-secondary'}" onclick="switchStream('${group.name}', '${inst.execution_id}', 'stderr')">stderr</button>
                                                <button type="button" class="btn btn-sm btn-secondary" onclick="refreshLogs('${group.name}', '${inst.execution_id}')"><i class="bi bi-arrow-clockwise"></i> Refresh</button>
                                            </div>
                                            <div class="log-content border" id="log-content-${inst.execution_id}"></div>
                                        </div>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                `).join('');

                // Restore saved log content after HTML regeneration
                Object.keys(savedLogContent).forEach(executionId => {
                    const logDiv = document.getElementById(`log-content-${executionId}`);
                    if (logDiv && savedLogContent[executionId]) {
                        logDiv.textContent = savedLogContent[executionId];
                    }
                });
            } catch (error) {
                console.error('Error fetching running processes:', error);
            }
        }

        function toggleGroup(name) {
            const group = document.getElementById(`group-${name}`);
            group.classList.toggle('expanded');

            // Update persistent state
            if (group.classList.contains('expanded')) {
                expandedGroups.add(name);
            } else {
                expandedGroups.delete(name);
            }
        }

        // Update stopped processes
        async function updateStoppedProcesses() {
            try {
                const response = await fetch('/api/processes/stopped');
                if (!response.ok) return;

                const groups = await response.json();
                const list = document.getElementById('stopped-list');

                if (groups.length === 0) {
                    list.innerHTML = '<div class="alert alert-success text-center"><i class="bi bi-check-circle fs-1 d-block mb-3"></i>No stopped processes</div>';
                    return;
                }

                // Save current expansion state before updating
                const currentExpandedGroups = new Set();
                groups.forEach((group, idx) => {
                    const elem = document.getElementById(`group-stopped-${group.name}`);
                    if (elem && elem.classList.contains('expanded')) {
                        currentExpandedGroups.add(`stopped-${group.name}`);
                    }
                });
                // Merge with persistent state
                currentExpandedGroups.forEach(name => expandedGroups.add(name));

                // Save log content before regenerating
                const savedLogContent = {};
                groups.forEach(group => {
                    group.instances.forEach(inst => {
                        const logDiv = document.getElementById(`log-content-${inst.execution_id}`);
                        if (logDiv) {
                            savedLogContent[inst.execution_id] = logDiv.textContent;
                        }
                    });
                });

                list.innerHTML = groups.map((group, idx) => `
                    <div class="card mb-3 border-start border-secondary border-3">
                        <div class="card-header bg-dark cursor-pointer" onclick="toggleGroup('stopped-${group.name}')" style="cursor: pointer;">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h6 class="mb-1 text-secondary">${group.name}</h6>
                                    <p class="mb-0 text-muted small">${group.description || group.script_path}</p>
                                </div>
                                <span class="badge bg-secondary">${group.instances.length} stopped</span>
                            </div>
                        </div>
                        <div class="group-instances ${expandedGroups.has('stopped-' + group.name) ? 'expanded' : ''}" id="group-stopped-${group.name}">
                            <ul class="list-group list-group-flush">
                                ${group.instances.map(inst => `
                                    <li class="list-group-item">
                                        <div class="d-flex justify-content-between align-items-start mb-2">
                                            <div class="flex-grow-1">
                                                <div class="font-monospace small text-primary">ID: ${inst.execution_id}</div>
                                                <div class="text-muted small">
                                                    Status: ${inst.status} | Exit code: ${inst.exit_code !== null ? inst.exit_code : 'N/A'} | Started: ${new Date(inst.start_time).toLocaleString()}
                                                </div>
                                            </div>
                                            <button class="btn btn-secondary btn-sm" onclick="toggleLogs('${group.name}', '${inst.execution_id}')">Logs</button>
                                        </div>
                                        <div class="logs-accordion ${activeLogs[inst.execution_id] ? 'active' : ''}" id="logs-${inst.execution_id}">
                                            <div class="btn-group mb-3" role="group">
                                                <button type="button" class="btn btn-sm ${!activeLogs[inst.execution_id] || activeLogs[inst.execution_id].stream === 'stdout' ? 'btn-primary' : 'btn-secondary'}" onclick="switchStream('${group.name}', '${inst.execution_id}', 'stdout')">stdout</button>
                                                <button type="button" class="btn btn-sm ${activeLogs[inst.execution_id]?.stream === 'stderr' ? 'btn-primary' : 'btn-secondary'}" onclick="switchStream('${group.name}', '${inst.execution_id}', 'stderr')">stderr</button>
                                                <button type="button" class="btn btn-sm btn-secondary" onclick="refreshLogs('${group.name}', '${inst.execution_id}')"><i class="bi bi-arrow-clockwise"></i> Refresh</button>
                                            </div>
                                            <div class="log-content border" id="log-content-${inst.execution_id}"></div>
                                        </div>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                `).join('');

                // Restore saved log content
                Object.keys(savedLogContent).forEach(executionId => {
                    const logDiv = document.getElementById(`log-content-${executionId}`);
                    if (logDiv && savedLogContent[executionId]) {
                        logDiv.textContent = savedLogContent[executionId];
                    }
                });
            } catch (error) {
                console.error('Error fetching stopped processes:', error);
            }
        }

        // Clear stopped processes
        async function clearStoppedProcesses() {
            if (!confirm('Are you sure you want to delete all stopped process logs? This cannot be undone.')) {
                return;
            }

            try {
                const response = await fetch('/api/processes/stopped/clear', {
                    method: 'POST'
                });

                const result = await response.json();
                if (result.success) {
                    updateStoppedProcesses();
                } else {
                    alert('Failed to clear stopped processes');
                }
            } catch (error) {
                console.error('Error clearing stopped processes:', error);
                alert('Error clearing stopped processes');
            }
        }

        // Launch modal
        function openLaunchModal(name) {
            document.getElementById('launch-process-name').value = name;
            document.getElementById('launch-args').value = '';
            document.getElementById('launch-message').innerHTML = '';
            const modal = document.getElementById('launch-modal');
            modal.classList.add('show');
            modal.style.display = 'block';
            document.body.classList.add('modal-open');
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop fade show';
            backdrop.id = 'launch-modal-backdrop';
            document.body.appendChild(backdrop);
        }

        function closeLaunchModal() {
            const modal = document.getElementById('launch-modal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            document.body.classList.remove('modal-open');
            const backdrop = document.getElementById('launch-modal-backdrop');
            if (backdrop) backdrop.remove();
        }

        async function launchProcess(event) {
            event.preventDefault();

            const name = document.getElementById('launch-process-name').value;
            const argsStr = document.getElementById('launch-args').value.trim();
            const args = argsStr ? argsStr.split(/\s+/) : [];

            const messageDiv = document.getElementById('launch-message');

            try {
                const response = await fetch(`/api/processes/${name}/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ args })
                });

                const result = await response.json();

                if (result.success) {
                    messageDiv.innerHTML = `<div class="alert alert-success">Process launched successfully! PID: ${result.execution.pid}</div>`;
                    setTimeout(() => {
                        closeLaunchModal();
                        if (currentTab === 'running') {
                            updateRunningProcesses();
                        }
                    }, 1500);
                } else {
                    messageDiv.innerHTML = `<div class="alert alert-danger">Error: ${result.error}</div>`;
                }
            } catch (error) {
                messageDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }

        async function stopProcess(name) {
            try {
                const response = await fetch(`/api/processes/${name}/stop`, {
                    method: 'POST'
                });
                const result = await response.json();

                if (result.success) {
                    updateRunningProcesses();
                }
            } catch (error) {
                console.error('Error stopping process:', error);
            }
        }

        // Toggle inline logs accordion
        function toggleLogs(name, executionId) {
            const accordion = document.getElementById(`logs-${executionId}`);
            const isActive = accordion.classList.contains('active');

            if (isActive) {
                // Close accordion
                accordion.classList.remove('active');
                delete activeLogs[executionId];
            } else {
                // Open accordion and start loading logs
                accordion.classList.add('active');
                activeLogs[executionId] = { name, stream: 'stdout' };
                loadInlineLogs(name, executionId, 'stdout');
            }
        }

        // Switch between stdout and stderr
        function switchStream(name, executionId, stream) {
            // Update tracking and load logs
            activeLogs[executionId] = { name, stream };
            loadInlineLogs(name, executionId, stream);
        }

        // Load logs for a specific execution
        async function loadInlineLogs(name, executionId, stream) {
            try {
                const response = await fetch(`/api/processes/${name}/logs/${stream}`);
                const data = await response.json();
                const contentDiv = document.getElementById(`log-content-${executionId}`);
                if (contentDiv) {
                    contentDiv.textContent = data.content || 'No logs available';
                }
            } catch (error) {
                console.error('Error loading logs:', error);
                const contentDiv = document.getElementById(`log-content-${executionId}`);
                if (contentDiv) {
                    contentDiv.textContent = 'Error loading logs';
                }
            }
        }

        // Refresh logs for current stream
        function refreshLogs(name, executionId) {
            const logInfo = activeLogs[executionId];
            if (logInfo) {
                loadInlineLogs(name, executionId, logInfo.stream);
            }
        }

        // Register modal
        function openRegisterModal() {
            const modal = document.getElementById('register-modal');
            modal.classList.add('show');
            modal.style.display = 'block';
            document.body.classList.add('modal-open');
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop fade show';
            backdrop.id = 'register-modal-backdrop';
            document.body.appendChild(backdrop);
            document.getElementById('register-form').reset();
            document.getElementById('register-message').innerHTML = '';
        }

        function closeRegisterModal() {
            const modal = document.getElementById('register-modal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            document.body.classList.remove('modal-open');
            const backdrop = document.getElementById('register-modal-backdrop');
            if (backdrop) backdrop.remove();
        }

        async function registerProcess(event) {
            event.preventDefault();

            const form = event.target;
            const formData = new FormData(form);
            const data = {
                name: formData.get('name'),
                script_path: formData.get('script_path'),
                cron_expr: formData.get('cron_expr') || null,
                description: formData.get('description') || ''
            };

            const messageDiv = document.getElementById('register-message');

            try {
                const response = await fetch('/api/processes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                const result = await response.json();

                if (result.success) {
                    messageDiv.innerHTML = `<div class="alert alert-success">Process "${data.name}" registered successfully!</div>`;
                    form.reset();
                    setTimeout(() => {
                        updateLaunchableProcesses();
                        closeRegisterModal();
                    }, 1500);
                } else {
                    messageDiv.innerHTML = `<div class="alert alert-danger">Error: ${result.error}</div>`;
                }
            } catch (error) {
                messageDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }

        async function updateSchedulerInfo() {
            try {
                const response = await fetch('/api/scheduler');
                const info = await response.json();

                const indicator = document.getElementById('scheduler-indicator');
                const status = document.getElementById('scheduler-status');
                const toggle = document.getElementById('scheduler-toggle');

                if (info.running) {
                    indicator.classList.remove('stopped');
                    status.textContent = `Scheduler: Running (${info.scheduled_processes.length} scheduled)`;
                    toggle.textContent = 'Stop Scheduler';
                } else {
                    indicator.classList.add('stopped');
                    status.textContent = 'Scheduler: Stopped';
                    toggle.textContent = 'Start Scheduler';
                }
            } catch (error) {
                console.error('Error fetching scheduler info:', error);
            }
        }

        async function toggleScheduler() {
            try {
                const response = await fetch('/api/scheduler');
                const info = await response.json();

                const action = info.running ? 'stop' : 'start';
                await fetch(`/api/scheduler/${action}`, { method: 'POST' });

                updateSchedulerInfo();
            } catch (error) {
                console.error('Error toggling scheduler:', error);
            }
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal')) {
                if (e.target.id === 'launch-modal') {
                    closeLaunchModal();
                } else if (e.target.id === 'register-modal') {
                    closeRegisterModal();
                }
            }
        });

        // Socket.IO connection
        socket.on('connect', () => {
            console.log('Connected to server');
        });

        socket.on('status_update', () => {
            if (currentTab === 'launchable') {
                updateLaunchableProcesses();
            } else {
                updateRunningProcesses();
            }
        });

        // Initial load
        window.addEventListener('load', async () => {
            const authenticated = await checkAuth();
            if (authenticated) {
                updateLaunchableProcesses();
                updateSchedulerInfo();

                // Poll for updates
                setInterval(() => {
                    if (currentTab === 'launchable') {
                        updateLaunchableProcesses();
                    } else if (currentTab === 'running') {
                        updateRunningProcesses();
                    } else if (currentTab === 'stopped') {
                        updateStoppedProcesses();
                    }
                }, 2000);

                setInterval(updateSchedulerInfo, 5000);
            }
        });
    </script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
</body>
</html>
